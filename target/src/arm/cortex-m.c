/*
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>
 *
 */

#include <stdint.h>
#include "gdb_packets.h"
#include "hex.h"
#include "result.h"
#include "swd.h"
#include "debug_log.h"


/** System Handler Control and State Register
 * Controls and provides the status of system handlers.
 *
 * bit 15 : SVCALLPENDED: 0= SVCall is not pending; 1= SVCall is pending.
 */
#define SHCSR 0xe000ed24

/** Debug Fault Status Register
 * Provides the top level reason why a debug event has occurred
 *
 * bit 4: EXTERNAL : 1= EDBGRQ debug event
 * bit 3: VCATCH : 1= vector catch debug event
 * bit 2: DWTTRAP: 1=debug event generated by Watchpoint
 * bit 1: BKPT: 1= breakpoint event
 * bit 0: HALTED: 1= halt request (Halt or Step)
 *
 */
#define DFSR 0xe000ed30

/** Debug Halting Control and Status Register
 * Controls halting debug.
 *
 * write only:
 * bit 31-16: DBGKEY must be 0xa05f to enable write access.
 *
 * read only:
 * bit 25: S_RESET_ST: 0 = no reset since last DHCSR read 1= at least one reset since last DHCSR read.
 * bit 24: S_RETIRE_ST: 0= no instruction executed since last DHCSR read; 1= at least one instruction executed since last DHCSR read.
 * bit 19: S_LOCKUP: 0= not locked up; 1 = processor is locked up due to unrecoverable exception.
 * bit 18: S_SLEEP: 0= not sleeping; 1 = sleepig
 * bit 17: S_HALT: 0= not in debug state; 1= in Debug state.
 * bit 16: S_REGRDY: 0= There has been a write to the DCRDR, but the transfer is not complete; 1= The transfer to or from the DCRDR is complete.
 *
 * read and write:
 * bit 3: C_MASKINTS: 0= do not mask; 1= Mask PendSV, SysTick and external configurable interrupts.
 * bit 2: C_STEP: 0= single stepping disabled; 1 = single stepping enabled.
 * bit 1: C_HALT: 0= Request a halted processor to run; 1= Request a running processor to halt.
 * bit 0: C_DEBUGEN: 0= Halting debug disabled; 1= Halting debug enabled.
 *
 */
#define DHCSR 0xe000edf0
#define DBGKEY 0xa05f0000

/** Debug Core Register Selector Register
 *  bits 31..17 = reserved
 *  bit 16 = REGWnR (0 = read, 1 = write)
 *  bits 15..5 = reserved
 *  bits 4..0 REGSEL= specifies the register to transfer:
 *
 *  0 0 0 0 0  : R0
 *  0 0 0 0 1  : R1
 *  0 0 0 1 0  : R2
 *  0 0 0 1 1  : R3
 *  0 0 1 0 0  : R4
 *  0 0 1 0 1  : R5
 *  0 0 1 1 0  : R6
 *  0 0 1 1 1  : R7
 *  0 1 0 0 0  : R8
 *  0 1 0 0 1  : R9
 *  0 1 0 1 0  : R10
 *  0 1 0 1 1  : R11
 *  0 1 1 0 0  : R12
 *  0 1 1 0 1  : SP (current stack pointer)
 *  0 1 1 1 0  : LR
 *  0 1 1 1 1  : Debug Return Address (first instruction to be executed on exit from Debug state)
 *  1 0 0 0 0  : xPSR
 *  1 0 0 0 1  : MSP (Main Stack Pointer)
 *  1 0 0 1 0  : PSP (Process Stack Pointer)
 *  1 0 0 1 1  : reserved
 *  1 0 1 0 0  : CONTROL / PRIMASK
 *  1 0 1 0 1  : reserved
 *   . . . .   : reserved
 *  1 1 1 1 1  : reserved
 */
#define DCRSR 0xe000edf4

/** Debug Core Register Data Register
 *
 */
#define DCRDR 0xe000edf8

/** Debug Exception and Monitor Control Register
 * Manages vector catch behavior and enables the DWT.
 *
 * bit 24: DWTENA: 0= DWT disabled; 1= DWT enabled.
 * bit 10: VC_HARDERR: 0= haling on HardFault disabled; 1= halting on HardFault enabled.
 * bit 0: VC_CORERESET: 0= Reset Vector Catch disabled; 1= Reset Vector Catch enabled.
 */
#define DEMCR 0xe000edfc


// static Result write_specialRegisters(bool first_call, uint32_t regsel, uint32_t data);
static Result read_specialRegisters(bool first_call, uint32_t regsel, uint32_t* data);

static uint32_t val_DHCSR;
static uint32_t val_DEMCR;


Result cortex_m_init(bool first_call)
{
    static Result phase = 0;
    Result res;
    if(true == first_call)
    {
        phase = 1;
    }
    // init the registers to the values needed.
    if(1 == phase)
    {
        // TODO support attach to running CPU
        val_DHCSR = 3;  // C_DEBUGEN = 1; C_HALT = 1;
        // Result swd_write_ap(uint32_t addr, uint32_t data);
        res = swd_write_ap(DHCSR, DBGKEY | (0xffff & val_DHCSR));
        if(RESULT_OK == res)
        {
            phase = 2;
        }
        else
        {
            return res;
        }
    }

    if(2 == phase)
    {
        // TODO DEMCR.DWTENA bit to 1 to enable Watch points
        val_DEMCR = (1 << 24) | (1 << 10) | 1;
        res = swd_write_ap(DEMCR, val_DEMCR);
        if(RESULT_OK == res)
        {
            phase = 3;
        }
        else
        {
            return res;
        }
    }

    if(3 == phase)
    {
        val_DHCSR = 0xf;
        res = swd_write_ap(DHCSR, DBGKEY | (0xffff & val_DHCSR));
        if(RESULT_OK == res)
        {
            phase = 4;
        }
        else
        {
            return res;
        }
    }

    if(4 == phase)
    {
        return RESULT_OK;
    }

    debug_line("cortex m init: invalid phase!");
    return ERR_WRONG_STATE;
}


Result cortex_m_halt_cpu(bool first_call)
{
    // halt target DHCSR.C_HALT = 1 + check that DHCSR.S_HALT is 1
    static Result phase = 0;
    static Result transaction_id = 0;
    Result res;
    if(true == first_call)
    {
        phase = 1;
    }

    // write the halt command
    if(1 == phase)
    {
        uint32_t new_val = val_DHCSR | (1 <<1);
        if(new_val != val_DHCSR)
        {
            res = swd_write_ap(DHCSR, DBGKEY | (0xffff & val_DHCSR));
            if(RESULT_OK == res)
            {
                phase = 2;
            }
            else
            {
                return res;
            }
        }
        else
        {
            // already commanded to halt
            phase = 2;
        }
    }

    // read the status register
    if(2 == phase)
    {
        res = swd_read_ap(DHCSR);
        if(RESULT_OK < res)
        {
            transaction_id = res;
            phase = 3;
        }
        else
        {
            return res;
        }
    }

    // check if Halt status bit is set.
    if(3 == phase)
    {
        uint32_t data;
        res = swd_get_result(transaction_id, &data);
        if(RESULT_OK == res)
        {
            if(0 == (data & (1<<17)))
            {
                // not yet halted -> read again
                phase = 2;
                return ERR_NOT_COMPLETED;
            }
            else
            {
                // halted !
                phase = 4;
            }
        }
        else
        {
            return res;
        }
    }

    if(4 == phase)
    {
        return RESULT_OK;
    }

    debug_line("halt cpu: invalid phase (%ld)!", phase);
    return ERR_WRONG_STATE;
}

Result cortex_m_add_general_registers(bool first_call)
{
    static uint32_t phase = 0;
    static uint32_t i;
    static uint32_t read;

    if(true == first_call)
    {
        i = 0;
        read = 0;
        phase = 1;
    }

    if((1 == phase) || (2 == phase))
    {
        // write i to DCRSR
        Result res;
        if(1 == phase)
        {
            res = read_specialRegisters(true, i, &read);
            phase = 2;
        }
        else
        {
            res = read_specialRegisters(false, i, &read);
        }
        if(RESULT_OK == res)
        {
            char buf[9];
            buf[8] = 0;
            int_to_hex(buf, read, 8);
            reply_packet_add(buf);
            i++;
            phase = 1;
            if(17 == i)
            {
                // finished
                return RESULT_OK;
            }
            else
            {
                // continue with next register
                return ERR_NOT_COMPLETED;
            }
        }
        else
        {
            return res;
        }
    }

    debug_line("add general registers: invalid phase!");
    return ERR_WRONG_STATE;
}

/*
static Result write_specialRegisters(bool first_call, uint32_t regsel, uint32_t data)
{

    // 1. write data to DCRDR
    // 2. write to DCRSR the REGSEL + REGWnR = 1
    // 3. read DHCSR until S_REGRDY is 1

    return ERR_WRONG_STATE;
}
*/

static Result read_specialRegisters(bool first_call, uint32_t regsel, uint32_t* data)
{
    static Result phase = 0;
    static Result transaction_id = 0;
    Result res;
    if(true == first_call)
    {
        phase = 1;
    }

    // 1. write to DCRSR the REGSEL value and REGWnR = 0
    if(1 == phase)
    {
        res = swd_write_ap(DCRSR, regsel);
        if(RESULT_OK == res)
        {
            phase = 2;
        }
        else
        {
            return res;
        }
    }

    // 2. read DHCSR until S_REGRDY is 1
    if(2 == phase)
    {
        res = swd_read_ap(DHCSR);
        if(RESULT_OK < res)
        {
            transaction_id = res;
            phase = 3;
        }
        else
        {
            return res;
        }
    }

    // ...until S_REGRDY is 1
    if(3 == phase)
    {
        res = swd_get_result(transaction_id, &val_DHCSR);
        if(RESULT_OK == res)
        {
            if(0 == (val_DHCSR & (1<<16)))
            {
                // no data available -> read again
                phase = 2;
            }
            else
            {
                // data available -> read data
                phase = 4;
            }
        }
        else
        {
            return res;
        }
    }

    // 3. read data from DCRDR
    if(4 == phase)
    {
        res = swd_read_ap(DCRDR);
        if(RESULT_OK < res)
        {
            transaction_id = res;
            phase = 5;
        }
        else
        {
            return res;
        }
    }

    // read the data
    if(5 == phase)
    {
        uint32_t reg_data;
        res = swd_get_result(transaction_id, &reg_data);
        if(RESULT_OK == res)
        {
            *data = reg_data;
            phase = 6;
        }
        else
        {
            return res;
        }
    }

    if(6 == phase)
    {
        return RESULT_OK;
    }

    debug_line("read special registers: invalid phase!");
    return ERR_WRONG_STATE;
}
